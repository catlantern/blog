

| 目录          | 描述                                     |
| ------------- | ---------------------------------------- |
| arch          | 特定体系结构的源码                       |
| block         | 块设备 I/O 层                            |
| crypto        | 加密 API                                 |
| Documentation | 内核源码文档                             |
| drivers       | 设备驱动程序                             |
| firmware      | 使用某些驱动程序所需类型的设备固件       |
| fs            | VFS 和各种文件系统                       |
| include       | 内核头文件                               |
| init          | 内核引导初始化代码                       |
| ipc           | 进程间通信代码                           |
| kernel        | 镜像相关版本的内核核心子系统             |
| lib           | 通用内核函数                             |
| mm            | 内存管理子系统和 VM                      |
| net           | 网络子系统                               |
| samples       | 示例、示范代码                           |
| scripts       | 编译内核用的脚本                         |
| security      | Linux 安全模块                           |
| sound         | 语音子系统                               |
| usr           | 用于生成用户空间代码（所谓的 initramfs） |
| tools         | 在 Linux 开发中使用的工具                |

## 内核开发特点

包括以下几点：  

- 内核编程时既不能访问 C 库也不能访问标准的 C 头文件。  
- 内核编程时必须使用 GNU C。  
- 内核编程时缺乏像用户空间那样的内存保护机制。  
- 内核编程时难以执行浮点运算。  
- 内核给每个进程只有一个很小的栈地址。  
- 由于内核支持异步中断、抢占和 SMP，因此必须时刻注意同步和并发。  
- 要考虑可移植性的重要性。

**内联会导致占用更多的内存空间或更多的指令缓存**



### 内核内存不分页

- 内核使用的内存必须**始终驻留在物理内存中**
- 不能被交换(swap)到磁盘上
- 每个分配的字节都直接对应物理内存的字节



## 内核中不使用浮点数的原因

### 1. 用户态浮点操作的处理机制

**用户态浮点操作流程**：

```
用户程序 → 浮点指令 → CPU检测到浮点操作
↓
CPU产生陷阱(Trap) → 内核捕获陷阱
↓
内核保存整数状态 → 初始化浮点单元 → 切换到浮点模式
↓
执行浮点指令 → 完成计算
↓
返回用户态时 → 内核恢复整数状态
```

### 2. 内核不能"陷入"的含义

**"陷入"(Trap/Exception)**：

- 当发生异常时，CPU自动切换到内核态处理
- 用户程序可以被中断，内核来处理异常
- 但**内核本身不能再被"陷入"**

**问题场景**：

```c
c// 假设内核中使用浮点运算
void kernel_function() {
    float a = 3.14;
    float b = 2.71; 
    float result = a * b;  // 浮点指令
    
    // 如果此时发生浮点异常...
    // 谁来处理这个异常？内核不能再次"陷入"自己！
}
```

### 3. 内核使用浮点的复杂性

**需要手动处理的工作**：

1. **保存浮点寄存器状态**：

```assembly
assembly; 进入内核函数前
fsave [浮点寄存器状态]  ; 保存当前浮点状态
; ... 浮点运算 ...
frstor [浮点寄存器状态] ; 恢复浮点状态
```

1. **处理浮点异常**：

- 除零错误
- 溢出/下溢
- 无效操作等

1. **性能开销**：

- 频繁的状态保存/恢复
- 上下文切换开销大



## 内核栈小而固定的理解

### 1. 用户态栈 vs 内核栈对比

**用户态栈特点**：

- 大小通常为 **几MB到几十MB**
- 可以**动态增长**
- 每个进程有独立的栈空间
- 可以分配大数组、复杂结构体

**内核栈特点**：

- 大小**固定**（x86上通常是4KB或8KB）
- **不能动态增长**
- 每个CPU核心有独立的栈
- 必须**极度节省**使用

### 2. 具体大小对比

```
用户态栈：
- Linux默认: 8MB
- Windows默认: 1MB
- 可以通过ulimit调整

内核栈（x86架构）：
- 32位系统: 通常8KB（2页）
- 64位系统: 通常16KB（2页）
- 固定大小，编译时确定
```



## 内核同步和并发的理解

### 1. 内核并发的四个主要来源

#### 1.1 抢占多任务操作系统

```c
// 场景：两个进程在内核态执行
Process A: 正在执行系统调用 write()
           ↓ 被抢占
Process B: 开始执行系统调用 read() 
           ↓ 访问相同文件的inode
Process A: 恢复执行，同时访问相同inode
// → 数据竞争！
```

#### 1.2 对称多处理器系统(SMP)

```c
// 场景：多CPU同时执行
CPU0: write系统调用 → 访问文件inode
CPU1: read系统调用  → 同时访问同一文件inode  
// → 两个CPU同时修改相同数据！
```

#### 1.3 异步中断

```c
// 场景：中断打断正常执行
Kernel: 正在修改网络缓冲区数据
        ↓ 网卡中断到来
ISR:    中断处理程序也开始访问网络缓冲区
        // → 中断处理程序与正常代码竞争！
```

#### 1.4 内核抢占

```c
// 场景：高优先级任务抢占
Low Priority Task: 正在遍历链表
                   ↓ 被高优先级任务抢占
High Priority Task: 也开始遍历并修改同一链表
                   // → 两个任务同时访问链表！
```

### 2. 并发场景的组合复杂性

```
最复杂的情况 - 四重并发：
┌─────────────┬─────────────────────────────────┐
│ CPU0        │ CPU1                            │
├─────────────┼─────────────────────────────────┤
│ Task A      │ Task B                          │
│ (访问list)  │ (访问list)                      │
│     ↓       │     ↓                           │
│   抢占      │   网络中断ISR                   │
│     ↓       │   (也访问list)                  │
│ 高优先级Task│                                 │
│ (也访问list)│                                 │
└─────────────┴─────────────────────────────────┘
```

### 3. 竞争条件的实际例子

```c
// 危险的代码 - 没有同步保护
int global_counter = 0;

void increment_counter() {
    global_counter++;  // 这不是原子操作！
    // 实际上是：读取 → 加1 → 写回
}

// 并发执行的问题：
// CPU0: 读取global_counter (值=5)
// CPU1: 读取global_counter (值=5)  
// CPU0: 计算 5+1=6
// CPU1: 计算 5+1=6
// CPU0: 写回 6
// CPU1: 写回 6
// 结果：本应是7，实际是6！
```